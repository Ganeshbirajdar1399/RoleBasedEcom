**compare**
private readonly compareUrl = 'https://ecom-db-json.onrender.com/compare';
  private readonly MAX_ITEMS = 4; // Maximum allowed items in the list

  private compareList: any[] = [];

  private compareSubject = new BehaviorSubject<any[]>(this.compareList);
  private compareCountSubject = new BehaviorSubject<number>(0);

  constructor(private http: HttpClient) {
    // Initialize compare list
    this.getCompareItems().subscribe({
      next: (items) =>
        this.updateList(items, this.compareSubject, this.compareCountSubject),
      error: (err) => console.error('Error fetching compare items:', err),
    });
  }

  // Generic method to update list and its count
  private updateList(
    items: any[],
    subject: BehaviorSubject<any[]>,
    countSubject: BehaviorSubject<number>
  ): void {
    subject.next(items);
    countSubject.next(items.length);
  }

  // Add product to compare list
  addToCompare(product: any): Observable<any> {
    const compare = this.compareSubject.getValue();
    const existingItem = compare.find((item) => item.id === product.id);
    if (this.compareList.length >= this.MAX_ITEMS) {
      alert(
        `Compare list is full! You can only add up to ${this.MAX_ITEMS} items.`
      );
      return EMPTY;
    }

    if (this.compareList.some((item) => item.id === product.id)) {
      alert('Product is already in the compare list!');
      return EMPTY;
    }

    if (existingItem) {
      existingItem.quantity += 1;
      return this.http
        .put<any>(`${this.compareUrl}/${existingItem.id}`, existingItem)
        .pipe(
          tap(() => this.compareSubject.next([...compare])),
          catchError((error) => {
            console.error('Failed to compare:', error);
            throw error;
          })
        );
    } else {
      const newProduct = { ...product, quantity: 1 };
      return this.http.post<any>(this.compareUrl, newProduct).pipe(
        tap(() => this.compareSubject.next([...compare, newProduct])),
        catchError((error) => {
          console.error('Failed to add to cart:', error);
          throw error;
        })
      );
    }
  }

  getCompareObservable(): Observable<any[]> {
    return this.compareSubject.asObservable();
  }

  removeFromCompare(id: string): Observable<any> {
    const compare = this.compareSubject
      .getValue()
      .filter((item) => item.id !== id);
    this.compareSubject.next(compare);

    return this.http.delete(`${this.compareUrl}/${id}`).pipe(
      catchError((error) => {
        console.error('Failed to remove item:', error);
        throw error;
      })
    );
  }

  // Fetch all compare items from the server
  getCompareItems(): Observable<any[]> {
    return this.http.get<any[]>(this.compareUrl).pipe(
      catchError((error) => {
        console.error('Failed to fetch compare items:', error);
        return throwError(() => new Error('Failed to fetch compare items'));
      })
    );
  }

  getCompareCountObservable(): Observable<number> {
    return this.compareCountSubject.asObservable();
  }

  // Clear the compare list
  clearCompare(): void {
    this.compareList = [];
    this.updateList(
      this.compareList,
      this.compareSubject,
      this.compareCountSubject
    );
  }

  **cart**
  private readonly apiUrl = 'https://ecom-db-json.onrender.com/cart';
  private readonly apiUrlcart = 'https://ecom-db-json.onrender.com/';

  private cartItems: any[] = [];
  private totalAmount: number = 0;

  private cartSubject = new BehaviorSubject<any[]>([]);

  constructor(private http: HttpClient) {
    this.loadCartFromServer();
  }

  setCartItems(cartItems: any[], totalAmount: number): void {
    this.cartItems = cartItems;
    this.totalAmount = totalAmount;
  }
  getCartItems(): any[] {
    return this.cartItems;
  }

  getTotalAmount(): number {
    return this.totalAmount;
  }

  private loadCartFromServer(): void {
    this.http.get<any[]>(this.apiUrl).subscribe({
      next: (cartItems) => this.cartSubject.next(cartItems),
      error: (error) => console.error('Failed to load cart:', error),
    });
  }

  getCartItem(): Observable<any[]> {
    return this.http.get<any[]>(this.apiUrl).pipe(
      tap((response) => this.cartSubject.next(response)),
      catchError((error) => {
        console.error('Error in getCartItem:', error);
        throw error;
      })
    );
  }

  addToCart(product: any): Observable<any> {
    const cart = this.cartSubject.getValue();
    const existingItem = cart.find((item) => item.id === product.id);

    if (existingItem) {
      existingItem.quantity += 1;
      return this.http
        .put<any>(`${this.apiUrl}/${existingItem.id}`, existingItem)
        .pipe(
          tap(() => this.cartSubject.next([...cart])),
          catchError((error) => {
            console.error('Failed to update cart:', error);
            throw error;
          })
        );
    } else {
      const newProduct = { ...product, quantity: 1 };
      return this.http.post<any>(this.apiUrl, newProduct).pipe(
        tap(() => this.cartSubject.next([...cart, newProduct])),
        catchError((error) => {
          console.error('Failed to add to cart:', error);
          throw error;
        })
      );
    }
  }

  removeItem(id: string): Observable<any> {
    const cart = this.cartSubject.getValue().filter((item) => item.id !== id);
    this.cartSubject.next(cart);

    return this.http.delete(`${this.apiUrl}/${id}`).pipe(
      catchError((error) => {
        console.error('Failed to remove item:', error);
        throw error;
      })
    );
  }

  clearCart(): Observable<any> {
    return this.http
      .get<any[]>(`${this.apiUrlcart}/cart`)
      .pipe(
        switchMap((cartItems) =>
          forkJoin(
            cartItems.map((item) =>
              this.http.delete(`${this.apiUrlcart}/cart/${item.id}`)
            )
          )
        )
      );
  }

  getCartObservable(): Observable<any[]> {
    return this.cartSubject.asObservable();
  }

  **auth**
  private readonly apiUrl = 'https://ecom-db-json.onrender.com/users'; // Base API URL

  private userSubject: BehaviorSubject<any> = new BehaviorSubject<any>(
    this.getUser()
  );
  public user$ = this.userSubject.asObservable(); // Observable to subscribe to

  constructor(private http: HttpClient, private router: Router) {}

  login(email: string, password: string): Observable<any> {
    const queryParams = `?email=${email}&password=${password}`;
    return this.http.get<any[]>(`${this.apiUrl}${queryParams}`).pipe(
      map(([user]) => {
        if (user) {
          this.setUser(user);
          this.userSubject.next(user);
          alert(`${user.firstName} ${user.lastName} logged in successfully`);
          return user;
        }
        throw new Error('Invalid credentials');
      }),
      catchError((error) => {
        alert('Login failed');
        return throwError(() => new Error('Login failed'));
      })
    );
  }

  register(user: Users): Observable<Users> {
    return this.http.post<Users>(this.apiUrl, user).pipe(
      catchError((error) => {
        console.log('Error in adding users', error);
        return of(null as unknown as Users);
      })
    );
  }
  updateUser(updatedDetails: any): Observable<any> {
    return this.http.put(`${this.apiUrl}/${updatedDetails.id}`, updatedDetails);
  }

  DeletetData(id: string): Observable<Users> {
    return this.http.delete<Users>(`${this.apiUrl}/${id}`);
  }

  setUser(user: any): void {
    try {
      sessionStorage.setItem('user', JSON.stringify(user));
    } catch (error) {
      console.error('Error saving user data:', error);
    }
  }

  getUser(): any {
    try {
      const user = sessionStorage.getItem('user');
      return user ? JSON.parse(user) : null;
    } catch (error) {
      console.error('Error reading user data. Clearing corrupted data:', error);
      sessionStorage.removeItem('user');
      return null;
    }
  }

  getRole(): string {
    const user = this.getUser();
    return user?.role || ''; // Use optional chaining
  }

  isLoggedIn(): boolean {
    return !!this.getUser(); // Return true if user exists
  }

  logout(): void {
    if (confirm('Are you sure you want to log out?')) {
      sessionStorage.removeItem('user'); // Clear user data
      this.router.navigate(['']); // Navigate to the home page
      this.userSubject.next(null); // Emit a null value to indicate logged-out state
    }
  }

  fetchUsers(): Observable<Users[]> {
    return this.http.get<Users[]>(this.apiUrl).pipe(
      catchError((error) => {
        console.log('Error fetching users:', error);
        return of([]);
      })
    );
  }

  **get-service**
  apiUrl = 'https://ecom-db-json.onrender.com/products';
  webDataUrl = 'https://ecom-db-json.onrender.com/otherinfo';

  constructor(private http: HttpClient) {}

  // Fetch all products
  fetchData(): Observable<Product[]> {
    return this.http.get<Product[]>(this.apiUrl).pipe(
      catchError((error) => {
        console.error('Error fetching products:', error);
        return of([]); // Return an empty array in case of error
      })
    );
  }

  //search products
  searchProducts(query: string): Observable<any[]> {
    return this.http
      .get<any[]>(this.apiUrl)
      .pipe(
        map((products) =>
          products.filter((product) =>
            product.pname.toLowerCase().includes(query.toLowerCase())
          )
        )
      );
  }

  addData(product: Product): Observable<Product> {
    return this.http.post<Product>(this.apiUrl, product).pipe(
      catchError((error) => {
        console.error('Error adding product:', error);
        return of(null as unknown as Product); // Return null in case of error
      })
    );
  }

  addWebData(webdata: Webdata): Observable<Webdata> {
    return this.http.post<Webdata>(this.webDataUrl, webdata).pipe(
      catchError((error) => {
        console.error('Error adding product:', error);
        return of(null as unknown as Webdata); // Return null in case of error
      })
    );
  }
  // Fetch all webdatas
  fetchWebData(): Observable<Webdata[]> {
    return this.http.get<Webdata[]>(this.webDataUrl).pipe(
      catchError((error) => {
        console.error('Error fetching products:', error);
        return of([]); // Return an empty array in case of error
      })
    );
  }

  updateWebData(id: string, webdata: any): Observable<any> {
    const url = `${this.webDataUrl}/${id}`;
    return this.http.put<any>(url, webdata).pipe(
      catchError((error) => {
        console.error('Error updating webdata:', error);
        return throwError(() => new Error(error));
      })
    );
  }
  updateData(id: string, product: any): Observable<any> {
    const url = `${this.apiUrl}/${id}`;
    return this.http.put<any>(url, product).pipe(
      catchError((error) => {
        console.error('Error updating product:', error);
        return throwError(() => new Error(error));
      })
    );
  }

  deleteData(id: string) {
    return this.http.delete<Product>(`${this.apiUrl}/${id}`).pipe(
      catchError((error) => {
        console.error('Error in delete product:', error);
        return of(null as unknown as Product);
      })
    );
  }

  // Fetch and group products by brand
  fetchGroupedByBrand(): Observable<{ [brand: string]: Product[] }> {
    return this.fetchData().pipe(
      map((products: Product[]) =>
        products.reduce(
          (groups: { [brand: string]: Product[] }, product: Product) => {
            const brand = product.brand;
            (groups[brand] = groups[brand] || []).push(product);
            return groups;
          },
          {}
        )
      ),
      catchError((error) => {
        console.error('Error grouping products by brand:', error);
        return of({}); // Return an empty object in case of error
      })
    );
  }

  // Fetch filtered products by a specific brand
  fetchProductsByBrand(brand: string): Observable<Product[]> {
    return this.fetchGroupedByBrand().pipe(
      map(
        (groupedProducts: { [brand: string]: Product[] }) =>
          groupedProducts[brand] || []
      ),
      catchError((error) => {
        console.error('Error fetching products by brand:', error);
        return of([]); // Return an empty array in case of error
      })
    );
  }

  **global**
  private readonly apiUrl = 'https://ecom-db-json.onrender.com';
  private readonly apiOrders = 'https://ecom-db-json.onrender.com/orders';
  private readonly MAX_ITEMS = 20;

  private cartSubject = new BehaviorSubject<any[]>([]);
  private compareSubject = new BehaviorSubject<any[]>([]);
  private wishlistSubject = new BehaviorSubject<any[]>([]);

  constructor(private http: HttpClient) {
    this.loadList('cart', this.cartSubject);
    this.loadList('compare', this.compareSubject);
    this.loadList('wishlist', this.wishlistSubject);
  }

  // Get Observable Methods
  getCartObservable(): Observable<any[]> {
    return this.cartSubject.asObservable();
  }

  getCompareObservable(): Observable<any[]> {
    return this.compareSubject.asObservable();
  }

  getWishlistObservable(): Observable<any[]> {
    return this.wishlistSubject.asObservable();
  }

  // Alias Methods (Optional)
  getCartItems(): Observable<any[]> {
    return this.getCartObservable();
  }

  getCompareItems(): Observable<any[]> {
    return this.getCompareObservable();
  }

  getWishlistItems(): Observable<any[]> {
    return this.getWishlistObservable();
  }

  // Add Item
  addToCart(product: any): Observable<any> {
    return this.addItem('cart', product, this.cartSubject);
  }

  addToCompare(product: any): Observable<any> {
    return this.addItem('compare', product, this.compareSubject);
  }

  addToWishlist(product: any): Observable<any> {
    return this.addItem('wishlist', product, this.wishlistSubject);
  }

  // Remove Item
  removeFromCart(id: string): Observable<any> {
    return this.removeItem('cart', id, this.cartSubject);
  }

  removeFromCompare(id: string): Observable<any> {
    return this.removeItem('compare', id, this.compareSubject);
  }

  removeFromWishlist(id: string): Observable<any> {
    return this.removeItem('wishlist', id, this.wishlistSubject);
  }

  // Clear Items
  clearCart(): Observable<any> {
    return this.clearItems('cart', this.cartSubject);
  }

  clearCompare(): Observable<any> {
    return this.clearItems('compare', this.compareSubject);
  }

  clearWishlist(): Observable<any> {
    return this.clearItems('wishlist', this.wishlistSubject);
  }

  // Generic Methods
  private addItem(
    endpoint: string,
    product: any,
    subject: BehaviorSubject<any[]>
  ): Observable<any> {
    const list = subject.getValue();
    if (list.length >= this.MAX_ITEMS) {
      alert(`You can only add up to ${this.MAX_ITEMS} items.`);
      return EMPTY;
    }
    if (list.some((item) => item.id === product.id)) {
      alert('Product is already in the list!');
      return EMPTY;
    }

    return this.http.post<any>(`${this.apiUrl}/${endpoint}`, product).pipe(
      tap(() => subject.next([...list, product])),
      catchError((error) =>
        this.handleError(error, `Failed to add item to ${endpoint}`)
      )
    );
  }

  private removeItem(
    endpoint: string,
    id: string,
    subject: BehaviorSubject<any[]>
  ): Observable<any> {
    const updatedList = subject.getValue().filter((item) => item.id !== id);
    subject.next(updatedList);

    return this.http
      .delete(`${this.apiUrl}/${endpoint}/${id}`)
      .pipe(
        catchError((error) =>
          this.handleError(error, `Failed to remove item from ${endpoint}`)
        )
      );
  }

  private clearItems(
    endpoint: string,
    subject: BehaviorSubject<any[]>
  ): Observable<any> {
    const list = subject.getValue();
    subject.next([]);

    return forkJoin(
      list.map((item) =>
        this.http.delete(`${this.apiUrl}/${endpoint}/${item.id}`)
      )
    ).pipe(
      catchError((error) =>
        this.handleError(error, `Failed to clear items in ${endpoint}`)
      )
    );
  }

  private loadList(endpoint: string, subject: BehaviorSubject<any[]>): void {
    this.http
      .get<any[]>(`${this.apiUrl}/${endpoint}`)
      .pipe(
        tap((items) => subject.next(items)),
        catchError((error) =>
          this.handleError(error, `Failed to load ${endpoint} items`)
        )
      )
      .subscribe();
  }

  // Add this method to your GlobalService
  placeOrder(orderData: any): Observable<any> {
    return this.http
      .post<any>(`${this.apiUrl}/orders`, orderData)
      .pipe(
        catchError((error) => this.handleError(error, 'Failed to place order'))
      );
  }
  getTotal(): number {
    return this.cartSubject.getValue().reduce((total, item) => {
      const price = item.psp || 0; // Default to 0 if price is missing
      const quantity = item.quantity || 1; // Default to 1 if quantity is missing

      return total + price * quantity;
    }, 0);
  }

  fetchOrders(): Observable<any> {
    return this.http.get(this.apiOrders);
  }
  deleteOrder(id: string): Observable<any> {
    return this.http.delete(`${this.apiOrders}/${id}`);
  }

  private handleError(error: any, message: string): Observable<never> {
    console.error(message, error);
    return throwError(() => new Error(message));
  }

  **wishlist**
  private readonly wishlistUrl = 'https://ecom-db-json.onrender.com/wishlist';
  private readonly MAX_ITEMS = 4; // Maximum allowed items in the list

  private wishList: any[] = [];

  private wishlistCountSubject = new BehaviorSubject<number>(0);
  private wishlistSubject = new BehaviorSubject<any[]>(this.wishList);

  constructor(private http: HttpClient) {
    // Initialize wishlist
    this.getWishlistItems().subscribe({
      next: (items) =>
        this.updateList(items, this.wishlistSubject, this.wishlistCountSubject),
      error: (err) => console.error('Error fetching wishlist items:', err),
    });
  }

  // Generic method to update list and its count
  private updateList(
    items: any[],
    subject: BehaviorSubject<any[]>,
    countSubject: BehaviorSubject<number>
  ): void {
    subject.next(items);
    countSubject.next(items.length);
  }

  // Add product to wishlist
  addToWishlist(product: any): Observable<any> {
    const wishlist = this.wishlistSubject.getValue();
    const existingItem = wishlist.find((item) => item.id === product.id);

    if (this.wishList.length >= this.MAX_ITEMS) {
      alert(
        `Wishlist is full! You can only add up to ${this.MAX_ITEMS} items.`
      );
      return EMPTY;
    }

    if (this.wishList.some((item) => item.id === product.id)) {
      alert('Product is already in the wishlist!');
      return EMPTY;
    }

    if (existingItem) {
      existingItem.quantity += 1;
      return this.http
        .put<any>(`${this.wishlistUrl}/${existingItem.id}`, existingItem)
        .pipe(
          tap(() => this.wishlistSubject.next([...wishlist])),
          catchError((error) => {
            console.error('Failed to compare:', error);
            throw error;
          })
        );
    } else {
      const newProduct = { ...product, quantity: 1 };
      return this.http.post<any>(this.wishlistUrl, newProduct).pipe(
        tap(() => this.wishlistSubject.next([...wishlist, newProduct])),
        catchError((error) => {
          console.error('Failed to add to wishlist:', error);
          throw error;
        })
      );
    }
  }

  removeFromWishlist(id: string): Observable<any> {
    const wishlist = this.wishlistSubject
      .getValue()
      .filter((item) => item.id !== id);
    this.wishlistSubject.next(wishlist);

    return this.http.delete(`${this.wishlistUrl}/${id}`).pipe(
      catchError((error) => {
        console.error('Failed to remove item:', error);
        throw error;
      })
    );
  }

  getWishlistObservable(): Observable<any[]> {
    return this.wishlistSubject.asObservable();
  }

  // Fetch all wishlist items from the server
  getWishlistItems(): Observable<any[]> {
    return this.http.get<any[]>(this.wishlistUrl).pipe(
      catchError((error) => {
        console.error('Failed to fetch wishlist items:', error);
        return throwError(() => new Error('Failed to fetch wishlist items'));
      })
    );
  }

  getWishlistCountObservable(): Observable<number> {
    return this.wishlistCountSubject.asObservable();
  }

  // Clear the compare list
  clearWishlist(): void {
    this.wishList = [];
    this.updateList(
      this.wishList,
      this.wishlistSubject,
      this.wishlistCountSubject
    );
  }